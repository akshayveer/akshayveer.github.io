---
layout: post
title:  "Learn Go Part-2"
date:   2021-05-23 13:30:00 +0530
categories: go golang backend
description: differences in syntax or conventions between go and c, c++, java
---
Go is mainly designed for server side services. 

#### Methods
* Go does not have classes, but use methods to achive that. 
{% highlight go %}
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
{% endhighlight %}
* methods are special type of functions with receiver argument and we call using v.Abs()
* You can only declare a method with a receiver whose type is defined in the same package as the method
* We can define methods on non-structs as well by defining type as `type MyFloat float64` as float64 is defined in another package and based on above constriant we cannot delcare method directly on the primitive type
* methods can also be created on pointer receivers and only difference between them is that we can modify the underlying struct using pointer receiver whereas value receiver will get a copy and can't modify the original datastructure `func (v *Vertex) Scale(f float64)`
* while methods with pointer receivers take either a value or a pointer as the receiver when they are called
{% highlight go %}
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
{% endhighlight %}
* similarly, methods with value receivers take either a value or a pointer as the receiver when they are called

#### Interface
* An interface type is defined as a set of method signatures
{% highlight go %}
type Abser interface {
	Abs() float64
}
{% endhighlight %}
* A value of interface type can hold any value that implements those methods (i.e types which implement the interface)
* When a type implements pointer receiver, then we can assign pointer to interface variable not the value and viceversa 
{% highlight go %}
a = f  // a MyFloat implements Abser
a = &v // a *Vertex implements Abser
{% endhighlight %}
* A type implements an interface by implementing its methods. There is no explicit declaration of intent, no "implements" keyword.
* If the concrete value inside the interface itself is nil, the method will be called with a nil receiver. i.e if we assign nil pointer to interface and execute the method, then we are passing nil pointer to method of pointer receiver
{% highlight go %}
func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}
{% endhighlight %}
* The interface type that specifies zero methods is known as the empty interface `var i interface{}`. Here i can hold any value of any type
* A type assertion providees access to an interface's underlying concrete value `t, ok := i.(T)`
* we can hae a switch statement for type `switch v := i.(type) { case float: `
* Stringer interface is used by Print* for printing as string
* The error type is a built-in interface similar to `fmt.Stringer` which has a method `Error() string` used by fmt

#### Go routines
* Goroutines run in the same address space, so access to shared memory must be synchronized
* channels are a typed conduit through which you can send and receive values with the channel operator, `<-`
{% highlight go %}
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.fmt.Println(t.S)
}
ch := make(chan int) // create a channel
{% endhighlight %}
* By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables
* Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel `ch := make(chan int, 100)`
* A sender can close a channel by `close(ch)` to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression `v, ok := <-ch`, ok is `false` when channel is closed
* The loop `for i := range c` receives values from the channel repeatedly until it is closed
* Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic
* Channels aren't like files; you don't usually need to close them.
* The `select` statement lets a goroutine wait on multiple communication operations and blocks until one of its cases can run. It chooses one at random if multiple are ready
{% highlight go %}
for {
	select {
	case c <- x:
		x, y = y, x+y
	case <-quit:
		fmt.Println("quit")
		return
	}
}
{% endhighlight %}
* The default case in a select is run if no other case is ready. used to send or receive without blocking
* sync.Mutex provides Lock() and Unlock() function for mutual exclusion
* select statement can be used both for sending and receiving data to channel
* `<-chan` is input channel and `chan<-`  is output channel


#### General
* Multiple functions can read from the same channel until that channel is closed; this is called fan-out
* A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that's closed when all the inputs are closed. This is called fan-in.
* General pattern is to output a channel from a function which call go routine inside it, so that we know when function exits
* Go routines started inside function will keep running even after function returned
* `var wg sync.WaitGroup` use this to wait for list of go routines to complete - [pipeline blog][go-pipeline] 
* In desigining pipelines, we need to inform upstream stages that we are done, by closing the channel from downstream stage to upstream stage. This close is done as deferred callback

###### References
[go tour][go-tour]

[go-tour]: https://tour.golang.org/
[go-pipeline]: https://blog.golang.org/pipelines